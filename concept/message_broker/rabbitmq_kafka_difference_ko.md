# RabbitMQ vs Kafka

## RabbitMQ
- **별명**
  - 메시지 Broker
  - 인메모리 메시지 Broker
  - 메시지 큐 시스템
  - 전통적인 메시지 큐
  - 메시지 큐 모델 기반

- **프로토콜**
  - **AMQP (Advanced Message Queuing Protocol)**: RabbitMQ의 주요 프로토콜.
  - **MQTT (Message Queuing Telemetry Transport)**: 저대역폭 및 IoT 애플리케이션을 위해 설계된 경량 메시징 프로토콜.
  - **STOMP (Simple/Streaming Text Oriented Messaging Protocol)**: 주로 RabbitMQ를 웹 애플리케이션과 통합할 때 사용되는 텍스트 기반 프로토콜.
  - **HTTP**: RabbitMQ는 메시지 게시 및 관리를 위한 HTTP API를 제공하여 웹 애플리케이션에서도 사용 가능합니다.
  - **WebSocket**: RabbitMQ와 웹 클라이언트 간 양방향 실시간 메시징을 가능하게 하며, 실시간 대시보드나 채팅 시스템에 적합합니다.

- **데이터 저장**
  - **큐(Queue)**
    - RabbitMQ는 **smart broker, dumb consumer** 모델을 사용합니다:
      - 메시지는 큐에 저장되고, Consumer가 메시지를 확인(ACK)하면 삭제됩니다.
    - 메시지는 성능을 위해 메모리에 저장되지만, 신뢰성을 위해 디스크에 영구 저장할 수도 있습니다.
    - RabbitMQ는 **워크 큐(Work Queue)**를 사용하여 여러 Consumer 간 작업 부하를 균등하게 나눕니다.
    - Producer는 특정 큐에 메시지를 보내거나 교환(Exchange)과 라우팅 키를 사용하여 여러 큐로 브로드캐스트할 수 있습니다.
    - **우선순위 큐(Priority Queue)**와 **TTL(Time-To-Live)** 기능을 통해 메시지 전달을 세밀하게 제어할 수 있습니다.
    - 메시지는 소비 및 확인되기 전까지 큐에 남아 신뢰성을 보장합니다.

- **메시지 처리 방법**
  1. **Producer가 메시지를 교환(Exchange)으로 보냄**:
     - Producer는 메시지를 교환으로 전송하며, 교환은 메시지가 전달될 큐를 결정합니다.
     - 교환 유형:
       - **Direct Exchange**: 라우팅 키와 일치하는 큐로 메시지를 전달.
       - **Fanout Exchange**: 연결된 모든 큐에 메시지를 브로드캐스트.
       - **Topic Exchange**: 라우팅 키의 와일드카드 패턴에 따라 메시지를 라우팅.
       - **Header Exchange**: 라우팅 키 대신 헤더를 기반으로 메시지를 라우팅.
  2. **교환이 메시지를 큐로 라우팅**:
     - 교환 유형과 바인딩 규칙에 따라 메시지가 하나 이상의 큐로 전달됩니다.
  3. **Broker가 메시지를 큐에 저장**:
     - 메시지는 소비될 때까지 큐에 임시 저장되며, ACK가 발생할 때까지 다른 Consumer에게 숨겨집니다.
  4. **Consumer가 메시지를 가져가 처리**:
     - Consumer는 큐를 구독하여 메시지를 실시간으로 수신하고 처리합니다. 이는 RabbitMQ의 푸시 기반 전달 방식을 활용합니다.
  5. **Consumer가 메시지를 확인(ACK)**:
     - 성공적으로 처리한 후 Consumer는 Broker에 확인 신호를 보냅니다.
     - 설정된 시간 내에 확인되지 않은 메시지는 동일하거나 다른 Consumer에게 다시 전송됩니다.
  6. **메시지 삭제**:
     - Broker가 확인 신호를 받으면 메시지는 큐에서 삭제됩니다.
     - 확인되지 않은 메시지는 큐에 남아 재전송됩니다.

- **사용 예시**
  - 작업 분배
  - 실시간 알림
  - 이벤트 기반 마이크로서비스
  - 중간 규모 워크로드를 위한 신뢰성 있는 메시징

---

## Kafka
- **별명**
  - 이벤트 Broker
  - 로그 기반 메시지 Broker
  - 스트리밍 처리 시스템
  - 분산 스트리밍 플랫폼
  - 퍼블리시-구독 모델 기반

- **프로토콜**
  - **Kafka의 고유 프로토콜**: 높은 처리량과 낮은 지연 시간을 위해 설계된 TCP 기반 커스텀 프로토콜.
  - **HTTP/REST**: Confluent REST Proxy와 같은 도구를 통해 Kafka를 HTTP 기반으로 통합.
  - **gRPC**: 확장이나 타사 라이브러리를 통해 고성능 통신 가능.
  - **WebSocket**: 커넥터를 통해 실시간 WebSocket 스트리밍 지원.

- **데이터 저장**
  - **로그(Log)**
    - Kafka는 **dumb broker, smart consumer** 모델을 사용합니다:
      - 메시지는 **추가 전용 로그(append-only log)**에 저장되며, 소비 후에도 삭제되지 않습니다.
      - 메시지 유지 정책:
        - **시간 기반 유지(Time-based Retention)**: 설정된 시간을 초과한 메시지는 삭제됩니다.
        - **크기 기반 유지(Size-based Retention)**: 로그 크기가 설정된 한도를 초과하면 오래된 메시지가 삭제됩니다.
    - Consumer는 오프셋을 추적하여 장애 복구 또는 재처리가 가능합니다.
    - 토픽은 **파티션(Partition)**으로 나뉘어 병렬성과 확장성을 제공합니다.

- **메시지 처리 방법**
  1. **Producer가 메시지를 토픽으로 보냄**:
     - Producer는 메시지를 논리적으로 그룹화된 토픽에 전송합니다.
     - 메시지는 키를 기반으로 하거나 라운드로빈 방식으로 파티션에 분배됩니다.
  2. **Broker가 메시지를 파티션 로그에 저장**:
     - 메시지는 해당 파티션 로그에 추가됩니다.
     - 각 메시지는 오프셋(offset)으로 식별됩니다.
  3. **Consumer가 토픽을 구독**:
     - Consumer는 **Consumer Group**에 가입하여 토픽을 구독합니다.
     - Kafka는 동일한 Consumer 그룹 내에서 파티션을 Consumer에게 할당하여 각 파티션이 한 Consumer에 의해 처리되도록 합니다.
  4. **Consumer가 Broker에서 메시지를 폴링**:
     - Consumer는 특정 오프셋부터 메시지를 요청하여 재처리하거나 중단된 작업을 재개할 수 있습니다.
  5. **메시지 유지 및 삭제**:
     - 메시지는 디스크에 유지되며 소비 후에도 삭제되지 않습니다. 삭제는 다음과 같은 설정에 의해 관리됩니다:
       - **시간 기반 유지**: 설정된 유지 기간 동안 메시지 보관.
       - **크기 기반 유지**: 파티션 로그 크기 초과 시 오래된 메시지 삭제.
       - **압축(Compaction)**: 동일한 키를 가진 메시지 중 최신 버전만 유지.

- **사용 예시**
  - 실시간 데이터 스트리밍 (예: 로그 집계, 메트릭 수집)
  - 마이크로서비스의 이벤트 소싱
  - 고처리량 데이터 파이프라인
  - 스트리밍 ETL(추출, 변환, 적재)

---

### 주요 차이점

| 기능                     | RabbitMQ                                  | Kafka                                     |
|-------------------------|------------------------------------------|-----------------------------------------|
| **모델**                | 메시지 큐                                | 퍼블리시-구독, 이벤트 스트리밍            |
| **메시지 저장**           | 메모리(기본값), 디스크 선택 가능         | 디스크 기반 추가 전용 로그               |
| **메시지 삭제**           | 확인(ACK) 후 삭제                       | 유지 정책에 따라 보관                     |
| **클러스터링**            | 관리가 복잡                             | 분산 시스템에 최적화                     |
| **메시지 라우팅**         | 유연한 교환 및 라우팅 키                | 파티션 기반 라우팅                       |
| **처리량**                | 중간 수준                              | 매우 높음 (스트리밍에 최적화)             |
| **재처리 가능성**          | 기본적으로 지원하지 않음                | 오프셋을 통한 지원                        |
| **프로토콜**              | AMQP, MQTT, STOMP, HTTP, WebSocket      | Kafka 프로토콜, REST, gRPC, WebSocket     |
| **일반적인 사용 사례**      | 작업 분배, 알림                         | 실시간 스트리밍, 데이터 파이프라인          |


&nbsp;
&nbsp;
---

## Kafka Topic, Partition vs RabbitMQ Exchange, Queue
Kafka와 RabbitMQ를 비교할 때, 개념적으로 매핑되는 부분은 있지만 정확히 일치하지는 않습니다. **Kafka의 토픽과 파티션**을 **RabbitMQ의 개념**과 비교하면 다음과 같이 정리할 수 있습니다.

---

### **Kafka의 구조**
1. **토픽(Topic)**  
   - 데이터를 논리적으로 분류하는 **카테고리**.
   - Producer가 데이터를 보낼 때 이 데이터를 특정 토픽에 보내며, Consumer는 특정 토픽에서 데이터를 구독합니다.
   
2. **파티션(Partition)**  
   - 토픽의 데이터를 **물리적으로 나눈 단위**.
   - Kafka의 데이터는 특정 키(Partition Key)에 따라 파티션에 저장됩니다.
   - 데이터를 병렬 처리하거나 확장성을 높이는 데 도움을 줍니다.

---

### **RabbitMQ의 구조**
1. **익스체인지(Exchange)**  
   - 메시지를 라우팅하는 단위.
   - 메시지는 익스체인지에 발행되고, 라우팅 키와 바인딩 규칙에 따라 큐에 전달됩니다.
   - 익스체인지의 유형에 따라 (direct, fanout, topic, headers) 메시지 라우팅 방식이 결정됩니다.

2. **큐(Queue)**  
   - 메시지를 Consumer가 읽을 수 있도록 저장하는 단위.
   - RabbitMQ의 큐는 Kafka의 파티션처럼 동작한다고 볼 수 있습니다.

---

### **Kafka vs RabbitMQ 비교**
| Kafka                          | RabbitMQ                        | 설명                                         |
|--------------------------------|----------------------------------|----------------------------------------------|
| **토픽(Topic)**                | **익스체인지(Exchange)**        | 데이터를 논리적으로 분류하는 역할.            |
| **파티션(Partition)**          | **큐(Queue)**                   | 데이터를 저장하고 Consumer가 처리하는 단위.     |
| 메시지 키를 기반으로 **파티션**에 분배 | 라우팅 키를 기반으로 **큐**에 전달 | 데이터 분배 방식에서 개념적으로 유사.          |

---

### 주요 차이점
1. **데이터 저장 방식**  
   - Kafka: 데이터를 디스크에 저장하며, 파티션 단위로 로그를 유지합니다.  
   - RabbitMQ: 메시지는 메모리 또는 디스크에 저장되며, 큐에서 제거 후 소비됩니다.

2. **라우팅**  
   - Kafka: 메시지 키를 기반으로 파티션에 데이터를 분산.  
   - RabbitMQ: 익스체인지의 유형과 라우팅 키를 기반으로 큐에 메시지 전달.

3. **확장성**  
   - Kafka: 파티션 단위로 데이터를 분산 저장하여 확장성과 병렬 처리를 극대화.  
   - RabbitMQ: 큐 단위로 확장이 가능하지만, Kafka처럼 데이터가 파티션 단위로 분산되지 않음.

---

### 결론
- **Kafka의 토픽은 RabbitMQ의 익스체인지와 비슷한 역할**을 하고,  
- **Kafka의 파티션은 RabbitMQ의 큐와 유사**하게 작동합니다.

다만, Kafka는 로그 중심 아키텍처를 기반으로 대규모 데이터 스트림 처리에 최적화되어 있고, RabbitMQ는 메시지 라우팅과 작업 분산(워크 큐)에서 유용합니다. 목적에 따라 사용하는 방식이 달라집니다.





&nbsp;
&nbsp;
---

## 추가 정보

### 1. **RabbitMQ와 SQS의 유사점**

RabbitMQ는 메시지 가시성 처리 방식에서 AWS SQS와 유사하게 동작합니다. **Consumer**가 메시지를 가져가면, **Broker**는 해당 메시지를 다른 Consumer가 볼 수 없도록 숨깁니다. 설정된 시간 내에 Consumer가 `ACK`(확인 신호)를 보내지 않으면, 메시지는 다시 표시되어 다른 Consumer에게 전달될 수 있습니다.

| **기능**                | **RabbitMQ**                                | **AWS SQS**                                  |
|-------------------------|---------------------------------------------|----------------------------------------------|
| **메시지 가시성**         | 메시지는 확인될 때까지 숨겨집니다.            | 메시지는 가시성 타임아웃 동안 숨겨집니다.       |
| **재전송**              | 확인되지 않은 메시지는 다시 전송됩니다.        | 가시성 타임아웃 후 메시지가 다시 나타납니다.    |

**추가 질문**:
- **RabbitMQ는 TCP처럼 Broker가 Consumer에게 메시지를 푸시하는 방식인가요?**
  - 네, RabbitMQ는 **푸시 기반(push-based)** 방식으로 동작합니다. Broker는 AMQP 채널을 통해 Consumer와 지속적인 TCP 연결을 유지하면서 메시지를 Consumer에게 실시간으로 전송합니다. 이는 Broker가 메시지를 Consumer에게 적극적으로 전달하는 Publish/Subscribe 모델과 유사합니다.

- **`ACK`를 받지 못하면 어떻게 되나요?**
  - Broker가 설정된 시간 내에 `ACK`를 받지 못하면, RabbitMQ는 동일한 메시지를 다시 전송합니다. 이 메시지는 동일한 Consumer 또는 다른 가용 Consumer에게 전달될 수 있습니다. 이를 통해 메시지 전달 신뢰성이 보장되지만, 메시지가 중복 처리될 가능성도 존재합니다.

---

### 2. **RabbitMQ Consumer 폴링**

RabbitMQ는 메시지를 수신하기 위해 Consumer가 반복적으로 폴링(polling)할 필요가 없습니다. 대신 RabbitMQ는 **푸시 방식**으로 메시지를 Consumer에게 전달합니다. 이 방식은 Broker와 Consumer 간 지속적인 AMQP 채널 연결을 유지하여, 웹훅(Webhook) 스타일의 콜백이나 반복적인 폴링 없이 실시간 메시지 전달을 가능하게 합니다.

---

### 3. **RabbitMQ 클러스터링과 브로드캐스팅**

RabbitMQ는 클러스터링을 지원하지만, 단일 메시지를 클러스터의 여러 노드에 걸쳐 여러 큐로 분산시키는 기능은 기본적으로 제공하지 않습니다.
- 각 메시지는 특정 노드의 교환(Exchange)에 바인딩된 큐로 라우팅됩니다.
- 클러스터링을 활성화하면 메타데이터와 큐 정의는 모든 노드에 동기화되지만, 실제 메시지는 하나의 노드에만 저장됩니다.
- 여러 클러스터 또는 노드에 메시지를 브로드캐스트하려면 **Federation** 또는 **Shovel** 플러그인을 사용해야 합니다.

**추가 질문**:
- **RabbitMQ 클러스터에서 하나의 메시지는 하나의 큐에만 저장되나요?**
  - 네, RabbitMQ는 하나의 메시지를 단일 큐에만 저장합니다. 클러스터 환경에서도 동일한 메시지가 여러 큐에 복제되지는 않습니다.

---

### 4. **RabbitMQ는 Kafka와 같은 "토픽" 개념이 있는가?**

RabbitMQ에는 Kafka의 "토픽"과 동일한 개념은 없지만, **토픽 교환(Topic Exchange)**이라는 기능을 제공합니다. Topic Exchange는 라우팅 키와 와일드카드 패턴을 사용하여 메시지를 큐로 라우팅할 수 있습니다.
- 예: `order.created`라는 라우팅 키를 가진 메시지는 `order.*`와 같은 패턴을 가진 큐와 매칭될 수 있습니다.
- 이러한 라우팅은 유연성을 제공하지만, Kafka의 토픽-파티션 모델과는 다릅니다.

---

### 5. **Kafka 메시지 보관**

Kafka는 메시지가 소비되었는지 여부와 관계없이 디스크에 메시지를 저장합니다. 메시지 삭제는 다음과 같은 **유지 정책(retention policy)**에 따라 이루어집니다:
1. **시간 기반 유지(Time-based Retention)**: 설정된 시간(예: 7일)을 초과한 메시지는 삭제됩니다.
2. **크기 기반 유지(Size-based Retention)**: 로그 크기가 설정된 한도를 초과하면 오래된 메시지가 삭제됩니다.

Kafka는 개별 메시지에 대한 TTL(Time-To-Live) 메커니즘을 제공하지 않습니다. 대신:
- 유지 정책은 **토픽 단위**로 관리됩니다.
- 압축(compaction)을 통해 동일한 키를 가진 레코드의 최신 버전만 유지할 수도 있습니다.

**추가 질문**:
- **Kafka에 쌓인 데이터는 어떻게 처리되며 추가 로직이 필요한가요?**
  - Kafka는 유지 정책을 통해 데이터를 자동으로 관리하므로, 일반적으로 추가 로직이 필요하지 않습니다. 그러나 데이터를 아카이빙하려는 경우, HDFS나 Amazon S3 같은 외부 스토리지로 데이터를 전송하는 커넥터를 사용할 수 있습니다.

---

### 6. **Kafka의 토픽과 파티션**

Kafka는 **토픽(Topic)**과 **파티션(Partition)**을 명확히 구분합니다:
- **토픽**: 메시지를 그룹화하는 논리적 채널. 하나의 Kafka 인스턴스는 여러 토픽을 관리할 수 있으며, 각 토픽은 확장성을 위해 여러 파티션으로 나뉩니다.
- **파티션**: 토픽을 세분화한 단위로, 병렬 처리를 가능하게 합니다. 파티션 내부에서는 메시지 순서가 보장되지만, 파티션 간 순서 보장은 없습니다.

**메시지 라우팅**:
- Producer는 메시지를 토픽으로 전송하며, Kafka는 메시지를 저장할 적절한 파티션을 결정합니다.
- 파티션 선택은 다음 방식 중 하나로 이루어집니다:
  - **키 기반**: 동일한 키를 가진 메시지는 항상 동일한 파티션에 저장됩니다.
  - **라운드로빈**: 키가 없는 메시지는 모든 파티션에 균등하게 분배됩니다.

**추가 질문**:
- **메시지는 토픽을 통해 파티션으로 라우팅되나요?**
  - 네, 메시지는 먼저 토픽으로 전송되고, Kafka는 Producer 설정에 따라 적절한 파티션을 선택합니다.

- **Kafka 인스턴스 하나에 토픽은 몇 개까지 존재할 수 있나요?**
  - 하나의 Kafka 인스턴스는 여러 개의 토픽을 관리할 수 있습니다. 각 토픽은 여러 파티션으로 나뉘며, 파티션은 Kafka 클러스터에 분산됩니다.

- **파티션 내부에서 메시지는 어떻게 분배되나요?**
  - 메시지 분배는 Producer 설정에 따라 결정됩니다:
    - **키 기반 메시지**: 동일한 키를 가진 메시지는 항상 동일한 파티션으로 전송됩니다.
    - **키가 없는 메시지**: 라운드로빈 방식으로 모든 파티션에 균등하게 분배됩니다.

&nbsp;
&nbsp;
---
## 추가 정보 (Fanout)

**Fanout 방식**은 RabbitMQ와 Kafka 모두에서 사용할 수 있지만, 두 시스템의 설계와 목적이 다르기 때문에 **서비스 특성**에 따라 적합성도 달라집니다. 아래에서 RabbitMQ와 Kafka에서의 Fanout 방식의 차이점과 각각이 적합한 경우를 살펴보겠습니다.

---

### **1. RabbitMQ에서의 Fanout**
RabbitMQ는 **Message Broker**로, 메시지를 수신하고 큐를 통해 Consumer에게 전달하는 데 초점이 맞춰져 있습니다.  
**Fanout Exchange**는 메시지를 여러 큐로 **브로드캐스트**하는 데 매우 적합합니다.

#### **적합한 경우**
- **실시간 알림** 시스템:
  - 예: 하나의 이벤트(사용자 등록)를 이메일 서비스, SMS 서비스, 로깅 서비스에 전달.
- **이벤트 브로드캐스팅**:
  - 예: 이벤트를 여러 애플리케이션이나 서비스로 동시 전달.
- **작업 분산**:
  - 동일한 데이터를 여러 Consumer가 병렬로 처리해야 할 때.

#### **장점**
- 단순하고 설정이 쉽습니다.
- Fanout Exchange를 사용하면 라우팅 키를 고려하지 않고 모든 큐에 메시지를 전달할 수 있습니다.

#### **단점**
- 메시지가 한 번 소비되면 기본적으로 저장되지 않습니다. (메시지 소비 후 삭제)
- 큐가 없으면 메시지가 유실될 수 있습니다.
- 대규모 로그 기반 데이터 스트림에는 적합하지 않습니다.

---

### **2. Kafka에서의 Fanout**
Kafka는 **분산 스트리밍 플랫폼**으로, 로그 기반 데이터 처리가 주된 목적입니다. Kafka는 RabbitMQ와 다르게 **브로드캐스트**를 직접적으로 지원하지 않습니다. 하지만 다음의 방식으로 Fanout을 구현할 수 있습니다:

1. **여러 Consumer Group 사용**: 
   - 하나의 토픽에서 여러 Consumer Group이 동일한 메시지를 병렬로 처리.
2. **여러 토픽 사용**:
   - Producer가 동일한 메시지를 여러 토픽에 복제하여 브로드캐스트.

#### **적합한 경우**
- **대규모 데이터 스트리밍**:
  - 예: 애플리케이션 로그를 여러 분석 시스템(예: Elasticsearch, Hadoop)으로 전달.
- **이벤트 소싱**:
  - 예: 여러 서비스가 동일한 이벤트 로그를 필요로 하는 경우.
- **고가용성 데이터 처리**:
  - 메시지가 파티션에 저장되므로 Consumer가 메시지를 읽지 않아도 데이터 유실이 없습니다.

#### **장점**
- 데이터를 파티션 단위로 저장하여 높은 확장성과 안정성을 보장.
- 메시지 유실 없이 여러 Consumer Group이 데이터를 독립적으로 처리 가능.

#### **단점**
- RabbitMQ보다 설정이 복잡.
- 단순한 Fanout 브로드캐스트를 구현하는 데 직접적인 지원이 부족.

---

### **3. RabbitMQ vs Kafka: Fanout 사용 적합성**
| **특성**                  | **RabbitMQ**                                      | **Kafka**                                        |
|---------------------------|--------------------------------------------------|-------------------------------------------------|
| **Fanout 구현 방식**      | Fanout Exchange를 사용해 메시지 브로드캐스트      | Consumer Group 또는 여러 토픽으로 Fanout 가능    |
| **목적**                  | 메시지 라우팅과 작업 분산                        | 로그 기반 대규모 데이터 스트리밍                 |
| **데이터 저장**           | 메시지 소비 후 삭제 (Persistent 설정 가능)        | 메시지를 디스크에 저장, 유실 없음                |
| **적합한 서비스**         | 이벤트 알림, 실시간 메시징                       | 데이터 분석, 이벤트 소싱, 스트림 처리            |
| **확장성**                | 큐와 익스체인지를 기반으로 적당한 확장성 제공     | 파티션 단위로 뛰어난 확장성 제공                |

---

### **4. 결론: 서비스 특성에 따라 선택**
- **RabbitMQ가 적합한 경우**:
  - 실시간 알림과 같은 **짧은 수명**의 메시지가 중요할 때.
  - 메시지를 여러 서비스에 빠르게 전달해야 할 때.
  - 설정과 관리가 단순해야 할 때.

- **Kafka가 적합한 경우**:
  - **로그 기반 데이터 스트리밍**이나 대규모 이벤트 처리가 필요한 경우.
  - **데이터 영속성**이 중요하고, 메시지를 나중에 재처리해야 하는 경우.
  - 대규모 분산 시스템에서 안정적인 메시지 처리가 필요한 경우.

---

### **Tip**
Fanout 방식은 서비스 요구사항과 아키텍처에 따라 선택해야 합니다. **단순한 브로드캐스팅**이 목적이라면 RabbitMQ가 적합하고, **고속 데이터 스트리밍 및 영속성**이 중요하다면 Kafka를 고려하는 것이 좋습니다.