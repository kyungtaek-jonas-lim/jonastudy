# RabbitMQ vs Kafka

## RabbitMQ
- **별명**
  - 메시지 Broker
  - 인메모리 메시지 Broker
  - 메시지 큐 시스템
  - 전통적인 메시지 큐
  - 메시지 큐 모델 기반

- **프로토콜**
  - **AMQP (Advanced Message Queuing Protocol)**: RabbitMQ의 주요 프로토콜.
  - **MQTT (Message Queuing Telemetry Transport)**: 저대역폭 및 IoT 애플리케이션을 위해 설계된 경량 메시징 프로토콜.
  - **STOMP (Simple/Streaming Text Oriented Messaging Protocol)**: 주로 RabbitMQ를 웹 애플리케이션과 통합할 때 사용되는 텍스트 기반 프로토콜.
  - **HTTP**: RabbitMQ는 메시지 게시 및 관리를 위한 HTTP API를 제공하여 웹 애플리케이션에서도 사용 가능합니다.
  - **WebSocket**: RabbitMQ와 웹 클라이언트 간 양방향 실시간 메시징을 가능하게 하며, 실시간 대시보드나 채팅 시스템에 적합합니다.

- **데이터 저장**
  - **큐(Queue)**
    - RabbitMQ는 **smart broker, dumb consumer** 모델을 사용합니다:
      - 메시지는 큐에 저장되고, Consumer가 메시지를 확인(ACK)하면 삭제됩니다.
    - 메시지는 성능을 위해 메모리에 저장되지만, 신뢰성을 위해 디스크에 영구 저장할 수도 있습니다.
    - RabbitMQ는 **워크 큐(Work Queue)**를 사용하여 여러 Consumer 간 작업 부하를 균등하게 나눕니다.
    - Producer는 특정 큐에 메시지를 보내거나 교환(Exchange)과 라우팅 키를 사용하여 여러 큐로 브로드캐스트할 수 있습니다.
    - **우선순위 큐(Priority Queue)**와 **TTL(Time-To-Live)** 기능을 통해 메시지 전달을 세밀하게 제어할 수 있습니다.
    - 메시지는 소비 및 확인되기 전까지 큐에 남아 신뢰성을 보장합니다.

- **메시지 처리 방법**
  1. **Producer가 메시지를 교환(Exchange)으로 보냄**:
     - Producer는 메시지를 교환으로 전송하며, 교환은 메시지가 전달될 큐를 결정합니다.
     - 교환 유형:
       - **Direct Exchange**: 라우팅 키와 일치하는 큐로 메시지를 전달.
       - **Fanout Exchange**: 연결된 모든 큐에 메시지를 브로드캐스트.
       - **Topic Exchange**: 라우팅 키의 와일드카드 패턴에 따라 메시지를 라우팅.
       - **Header Exchange**: 라우팅 키 대신 헤더를 기반으로 메시지를 라우팅.
  2. **교환이 메시지를 큐로 라우팅**:
     - 교환 유형과 바인딩 규칙에 따라 메시지가 하나 이상의 큐로 전달됩니다.
  3. **Broker가 메시지를 큐에 저장**:
     - 메시지는 소비될 때까지 큐에 임시 저장되며, ACK가 발생할 때까지 다른 Consumer에게 숨겨집니다.
  4. **Consumer가 메시지를 가져가 처리**:
     - Consumer는 큐를 구독하여 메시지를 실시간으로 수신하고 처리합니다. 이는 RabbitMQ의 푸시 기반 전달 방식을 활용합니다.
  5. **Consumer가 메시지를 확인(ACK)**:
     - 성공적으로 처리한 후 Consumer는 Broker에 확인 신호를 보냅니다.
     - 설정된 시간 내에 확인되지 않은 메시지는 동일하거나 다른 Consumer에게 다시 전송됩니다.
  6. **메시지 삭제**:
     - Broker가 확인 신호를 받으면 메시지는 큐에서 삭제됩니다.
     - 확인되지 않은 메시지는 큐에 남아 재전송됩니다.

- **사용 예시**
  - 작업 분배
  - 실시간 알림
  - 이벤트 기반 마이크로서비스
  - 중간 규모 워크로드를 위한 신뢰성 있는 메시징

---

## Kafka
- **별명**
  - 이벤트 Broker
  - 로그 기반 메시지 Broker
  - 스트리밍 처리 시스템
  - 분산 스트리밍 플랫폼
  - 퍼블리시-구독 모델 기반

- **프로토콜**
  - **Kafka의 고유 프로토콜**: 높은 처리량과 낮은 지연 시간을 위해 설계된 TCP 기반 커스텀 프로토콜.
  - **HTTP/REST**: Confluent REST Proxy와 같은 도구를 통해 Kafka를 HTTP 기반으로 통합.
  - **gRPC**: 확장이나 타사 라이브러리를 통해 고성능 통신 가능.
  - **WebSocket**: 커넥터를 통해 실시간 WebSocket 스트리밍 지원.

- **데이터 저장**
  - **로그(Log)**
    - Kafka는 **dumb broker, smart consumer** 모델을 사용합니다:
      - 메시지는 **추가 전용 로그(append-only log)**에 저장되며, 소비 후에도 삭제되지 않습니다.
      - 메시지 유지 정책:
        - **시간 기반 유지(Time-based Retention)**: 설정된 시간을 초과한 메시지는 삭제됩니다.
        - **크기 기반 유지(Size-based Retention)**: 로그 크기가 설정된 한도를 초과하면 오래된 메시지가 삭제됩니다.
    - Consumer는 오프셋을 추적하여 장애 복구 또는 재처리가 가능합니다.
    - 토픽은 **파티션(Partition)**으로 나뉘어 병렬성과 확장성을 제공합니다.

- **메시지 처리 방법**
  1. **Producer가 메시지를 토픽으로 보냄**:
     - Producer는 메시지를 논리적으로 그룹화된 토픽에 전송합니다.
     - 메시지는 키를 기반으로 하거나 라운드로빈 방식으로 파티션에 분배됩니다.
  2. **Broker가 메시지를 파티션 로그에 저장**:
     - 메시지는 해당 파티션 로그에 추가됩니다.
     - 각 메시지는 오프셋(offset)으로 식별됩니다.
  3. **Consumer가 토픽을 구독**:
     - Consumer는 **Consumer Group**에 가입하여 토픽을 구독합니다.
     - Kafka는 동일한 Consumer 그룹 내에서 파티션을 Consumer에게 할당하여 각 파티션이 한 Consumer에 의해 처리되도록 합니다.
  4. **Consumer가 Broker에서 메시지를 폴링**:
     - Consumer는 특정 오프셋부터 메시지를 요청하여 재처리하거나 중단된 작업을 재개할 수 있습니다.
  5. **메시지 유지 및 삭제**:
     - 메시지는 디스크에 유지되며 소비 후에도 삭제되지 않습니다. 삭제는 다음과 같은 설정에 의해 관리됩니다:
       - **시간 기반 유지**: 설정된 유지 기간 동안 메시지 보관.
       - **크기 기반 유지**: 파티션 로그 크기 초과 시 오래된 메시지 삭제.
       - **압축(Compaction)**: 동일한 키를 가진 메시지 중 최신 버전만 유지.

- **사용 예시**
  - 실시간 데이터 스트리밍 (예: 로그 집계, 메트릭 수집)
  - 마이크로서비스의 이벤트 소싱
  - 고처리량 데이터 파이프라인
  - 스트리밍 ETL(추출, 변환, 적재)

---

### 주요 차이점

| 기능                     | RabbitMQ                                  | Kafka                                     |
|-------------------------|------------------------------------------|-----------------------------------------|
| **모델**                | 메시지 큐                                | 퍼블리시-구독, 이벤트 스트리밍            |
| **메시지 저장**           | 메모리(기본값), 디스크 선택 가능         | 디스크 기반 추가 전용 로그               |
| **메시지 삭제**           | 확인(ACK) 후 삭제                       | 유지 정책에 따라 보관                     |
| **클러스터링**            | 관리가 복잡                             | 분산 시스템에 최적화                     |
| **메시지 라우팅**         | 유연한 교환 및 라우팅 키                | 파티션 기반 라우팅                       |
| **처리량**                | 중간 수준                              | 매우 높음 (스트리밍에 최적화)             |
| **재처리 가능성**          | 기본적으로 지원하지 않음                | 오프셋을 통한 지원                        |
| **프로토콜**              | AMQP, MQTT, STOMP, HTTP, WebSocket      | Kafka 프로토콜, REST, gRPC, WebSocket     |
| **일반적인 사용 사례**      | 작업 분배, 알림                         | 실시간 스트리밍, 데이터 파이프라인          |




---

## 추가 정보

### 1. **RabbitMQ와 SQS의 유사점**

RabbitMQ는 메시지 가시성 처리 방식에서 AWS SQS와 유사하게 동작합니다. **Consumer**가 메시지를 가져가면, **Broker**는 해당 메시지를 다른 Consumer가 볼 수 없도록 숨깁니다. 설정된 시간 내에 Consumer가 `ACK`(확인 신호)를 보내지 않으면, 메시지는 다시 표시되어 다른 Consumer에게 전달될 수 있습니다.

| **기능**                | **RabbitMQ**                                | **AWS SQS**                                  |
|-------------------------|---------------------------------------------|----------------------------------------------|
| **메시지 가시성**         | 메시지는 확인될 때까지 숨겨집니다.            | 메시지는 가시성 타임아웃 동안 숨겨집니다.       |
| **재전송**              | 확인되지 않은 메시지는 다시 전송됩니다.        | 가시성 타임아웃 후 메시지가 다시 나타납니다.    |

**추가 질문**:
- **RabbitMQ는 TCP처럼 Broker가 Consumer에게 메시지를 푸시하는 방식인가요?**
  - 네, RabbitMQ는 **푸시 기반(push-based)** 방식으로 동작합니다. Broker는 AMQP 채널을 통해 Consumer와 지속적인 TCP 연결을 유지하면서 메시지를 Consumer에게 실시간으로 전송합니다. 이는 Broker가 메시지를 Consumer에게 적극적으로 전달하는 Publish/Subscribe 모델과 유사합니다.

- **`ACK`를 받지 못하면 어떻게 되나요?**
  - Broker가 설정된 시간 내에 `ACK`를 받지 못하면, RabbitMQ는 동일한 메시지를 다시 전송합니다. 이 메시지는 동일한 Consumer 또는 다른 가용 Consumer에게 전달될 수 있습니다. 이를 통해 메시지 전달 신뢰성이 보장되지만, 메시지가 중복 처리될 가능성도 존재합니다.

---

### 2. **RabbitMQ Consumer 폴링**

RabbitMQ는 메시지를 수신하기 위해 Consumer가 반복적으로 폴링(polling)할 필요가 없습니다. 대신 RabbitMQ는 **푸시 방식**으로 메시지를 Consumer에게 전달합니다. 이 방식은 Broker와 Consumer 간 지속적인 AMQP 채널 연결을 유지하여, 웹훅(Webhook) 스타일의 콜백이나 반복적인 폴링 없이 실시간 메시지 전달을 가능하게 합니다.

---

### 3. **RabbitMQ 클러스터링과 브로드캐스팅**

RabbitMQ는 클러스터링을 지원하지만, 단일 메시지를 클러스터의 여러 노드에 걸쳐 여러 큐로 분산시키는 기능은 기본적으로 제공하지 않습니다.
- 각 메시지는 특정 노드의 교환(Exchange)에 바인딩된 큐로 라우팅됩니다.
- 클러스터링을 활성화하면 메타데이터와 큐 정의는 모든 노드에 동기화되지만, 실제 메시지는 하나의 노드에만 저장됩니다.
- 여러 클러스터 또는 노드에 메시지를 브로드캐스트하려면 **Federation** 또는 **Shovel** 플러그인을 사용해야 합니다.

**추가 질문**:
- **RabbitMQ 클러스터에서 하나의 메시지는 하나의 큐에만 저장되나요?**
  - 네, RabbitMQ는 하나의 메시지를 단일 큐에만 저장합니다. 클러스터 환경에서도 동일한 메시지가 여러 큐에 복제되지는 않습니다.

---

### 4. **RabbitMQ는 Kafka와 같은 "토픽" 개념이 있는가?**

RabbitMQ에는 Kafka의 "토픽"과 동일한 개념은 없지만, **토픽 교환(Topic Exchange)**이라는 기능을 제공합니다. Topic Exchange는 라우팅 키와 와일드카드 패턴을 사용하여 메시지를 큐로 라우팅할 수 있습니다.
- 예: `order.created`라는 라우팅 키를 가진 메시지는 `order.*`와 같은 패턴을 가진 큐와 매칭될 수 있습니다.
- 이러한 라우팅은 유연성을 제공하지만, Kafka의 토픽-파티션 모델과는 다릅니다.

---

### 5. **Kafka 메시지 보관**

Kafka는 메시지가 소비되었는지 여부와 관계없이 디스크에 메시지를 저장합니다. 메시지 삭제는 다음과 같은 **유지 정책(retention policy)**에 따라 이루어집니다:
1. **시간 기반 유지(Time-based Retention)**: 설정된 시간(예: 7일)을 초과한 메시지는 삭제됩니다.
2. **크기 기반 유지(Size-based Retention)**: 로그 크기가 설정된 한도를 초과하면 오래된 메시지가 삭제됩니다.

Kafka는 개별 메시지에 대한 TTL(Time-To-Live) 메커니즘을 제공하지 않습니다. 대신:
- 유지 정책은 **토픽 단위**로 관리됩니다.
- 압축(compaction)을 통해 동일한 키를 가진 레코드의 최신 버전만 유지할 수도 있습니다.

**추가 질문**:
- **Kafka에 쌓인 데이터는 어떻게 처리되며 추가 로직이 필요한가요?**
  - Kafka는 유지 정책을 통해 데이터를 자동으로 관리하므로, 일반적으로 추가 로직이 필요하지 않습니다. 그러나 데이터를 아카이빙하려는 경우, HDFS나 Amazon S3 같은 외부 스토리지로 데이터를 전송하는 커넥터를 사용할 수 있습니다.

---

### 6. **Kafka의 토픽과 파티션**

Kafka는 **토픽(Topic)**과 **파티션(Partition)**을 명확히 구분합니다:
- **토픽**: 메시지를 그룹화하는 논리적 채널. 하나의 Kafka 인스턴스는 여러 토픽을 관리할 수 있으며, 각 토픽은 확장성을 위해 여러 파티션으로 나뉩니다.
- **파티션**: 토픽을 세분화한 단위로, 병렬 처리를 가능하게 합니다. 파티션 내부에서는 메시지 순서가 보장되지만, 파티션 간 순서 보장은 없습니다.

**메시지 라우팅**:
- Producer는 메시지를 토픽으로 전송하며, Kafka는 메시지를 저장할 적절한 파티션을 결정합니다.
- 파티션 선택은 다음 방식 중 하나로 이루어집니다:
  - **키 기반**: 동일한 키를 가진 메시지는 항상 동일한 파티션에 저장됩니다.
  - **라운드로빈**: 키가 없는 메시지는 모든 파티션에 균등하게 분배됩니다.

**추가 질문**:
- **메시지는 토픽을 통해 파티션으로 라우팅되나요?**
  - 네, 메시지는 먼저 토픽으로 전송되고, Kafka는 Producer 설정에 따라 적절한 파티션을 선택합니다.

- **Kafka 인스턴스 하나에 토픽은 몇 개까지 존재할 수 있나요?**
  - 하나의 Kafka 인스턴스는 여러 개의 토픽을 관리할 수 있습니다. 각 토픽은 여러 파티션으로 나뉘며, 파티션은 Kafka 클러스터에 분산됩니다.

- **파티션 내부에서 메시지는 어떻게 분배되나요?**
  - 메시지 분배는 Producer 설정에 따라 결정됩니다:
    - **키 기반 메시지**: 동일한 키를 가진 메시지는 항상 동일한 파티션으로 전송됩니다.
    - **키가 없는 메시지**: 라운드로빈 방식으로 모든 파티션에 균등하게 분배됩니다.