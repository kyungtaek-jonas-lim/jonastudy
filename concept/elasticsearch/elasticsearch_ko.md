# Elastic Search
- [Elastic Search](#elastic-search-1)
- [Elasticsearch vs RDBMS](#elasticsearch-vs-rdbms-비교)
- [Additional Info](#additional-info)

&nbsp;

## Elastic Search

### 1. **Elastic Search와 No-SQL의 적합성**
- **별명**
  - 분산 검색 엔진
  - 텍스트 검색엔진
  - 실시간 데이터 분석 플랫폼
  - NoSQL 데이터베이스
  - 분산형 데이터 저장소

- **적합성**
  - Elastic Search는 주로 **검색 엔진**으로 사용되지만, 문서 기반 데이터의 검색과 분석에 매우 적합합니다. 
  - **문서형 데이터** (JSON 형식의 데이터)를 저장하고, 검색 및 분석을 효율적으로 처리합니다.
  - **NoSQL**의 특성으로 비정형 데이터나 스키마가 동적인 데이터를 처리하는 데 강점을 보입니다.
  - 따라서, **문서 데이터**를 다룰 때 **Elastic Search**는 매우 적합한 선택입니다. 관계형 데이터베이스(RDBMS)가 아닌 **비정형 데이터를 다루기 좋은** 분산형 시스템으로서 빠른 검색 성능을 제공합니다.

---

### 2. **Elastic Search에 실시간 데이터 삽입**
- **별명**
  - 실시간 데이터 검색 엔진
  - 데이터 인덱싱 서비스
  - 빠른 검색 업데이트

- **데이터 삽입 방법**
  - **Elastic Search에 실시간 데이터를 삽입하는 방법**은 일반적으로 **CDC (Change Data Capture)**나 **메시지 큐 시스템**을 사용하는 경우가 많지만, 이 외에도 다른 방법을 사용할 수 있습니다.
  - 예를 들어, **DML** (INSERT, UPDATE, DELETE) 발생 시 **Elastic Search에 데이터를 삽입하는 방법**은 직접 **트리거** 또는 **데이터베이스와 Elastic Search 간의 동기화** 기능을 구현하여 가능합니다. 이때, **Kafka**와 같은 메시지 큐를 사용하는 방법이 널리 사용됩니다.
  - 하지만 **메시지 큐를 제외한 방법**으로는 직접 애플리케이션 로직에서 데이터 변경 시마다 **Elastic Search에 삽입**하는 방법도 있습니다. 이 방식은 실시간 데이터 동기화가 가능하지만, 시스템에 **부하가 추가될 수** 있습니다.

---

### 3. **ETL 파이프라인의 실시간 동기화**
- **별명**
  - 실시간 데이터 동기화
  - 데이터 파이프라인
  - ETL (Extract, Transform, Load)

- **ETL 실시간 동기화 여부**
  - ETL 파이프라인은 일반적으로 **배치 처리**를 위해 사용되지만, **실시간 동기화**도 가능합니다. 
  - Elastic Search에서는 **실시간** 데이터 처리가 중요할 경우, **스트리밍 방식**으로 데이터를 실시간으로 **ETL 파이프라인을 통해 전송**하는 방법을 사용할 수 있습니다. 이때 데이터가 **주기적으로**가 아닌 **즉시** 변동에 맞춰 전송됩니다.
  - 이 방식은 실시간 분석이나 모니터링에 유용합니다.

---

### 4. **Elastic Search에서 배치 작업 처리**
- **별명**
  - 배치 데이터 처리
  - 대규모 데이터 인덱싱
  - 데이터 처리 작업

- **배치 처리 방식**
  - Elastic Search는 기본적으로 **배치 작업**을 처리하는 데 적합하지만, 기본적으로 배치 작업을 **자동으로 실행하지 않습니다**.
  - 따라서 **배치 처리를 위해서는 별도의 로직**을 구현해야 합니다. 예를 들어, 특정 시간 간격으로 데이터를 Elastic Search로 **배치 삽입하는 시스템**을 구현하거나, **CRON jobs** 등을 사용하여 주기적으로 데이터를 삽입하는 방식이 필요합니다.
  - 기본적으로 서비스에서 **Elastic Search에 데이터 삽입**을 위한 로직을 구현해야 합니다.

---

### 5. **Elastic Search의 Full Text Index**
- **별명**
  - 텍스트 검색 인덱스
  - 빠른 검색 엔진
  - Full Text 검색

- **Full Text Index**
  - Elastic Search는 **Full Text Index**를 기본적으로 제공합니다.
  - **RDBMS**에서 제공하는 **Full Text Index**와 유사하게, 텍스트 데이터에 대해 **효율적인 검색**을 할 수 있습니다.
  - **검색 성능**은 Elastic Search가 훨씬 더 빠르고 효율적입니다. 이는 **분산형 시스템**과 **역색인(inverted index)**을 사용하여 빠른 텍스트 검색을 가능하게 하기 때문입니다.
  - 특히 **대용량 데이터**에 대해 **빠른 응답 속도**와 **효율적인 텍스트 검색**을 제공합니다.

---

### 6. **Elastic Search의 분산 방식**
- **별명**
  - 분산형 시스템
  - 데이터 샤딩
  - 분산 저장 시스템

- **분산 시스템**
  - Elastic Search는 **Master-Slave** 방식이 아닌 **분산 시스템**을 기반으로 한 **샤딩(sharding)**과 **리플리케이션(replication)**을 사용합니다.
  - **샤드**는 데이터를 여러 조각으로 나누어 **여러 노드**에 분산하여 저장합니다. 이를 통해 **수평 확장**이 가능하며, 고가용성과 부하 분산을 제공합니다.
  - **데이터 동기화**는 **자동으로** 이루어지며, **각 샤드**와 **리플리카 샤드** 간에 실시간으로 **동기화**됩니다.
  - **RDBMS의 Read Replica**와는 다르게 **Elastic Search는 데이터를 샤드에 분배하여 저장**하고, 이를 **리플리케이션**하여 고가용성을 제공합니다.

---

### 7. **오타 교정 및 검색 내역**
- **별명**
  - 오타 교정
  - 유사 검색
  - 텍스트 처리

- **오타 교정**
  - Elastic Search는 기본적으로 **오타에 대한 자동 교정 기능**을 제공합니다.
  - **비슷한 단어**나 **유사한 철자**를 자동으로 처리하는 **자동완성 기능**을 제공하며, **불완전한 검색어**에 대해서도 **유연한 검색**이 가능합니다.
  - 오타 tolerance는 **문서 매핑**과 **쿼리 파라미터**를 통해 설정할 수 있습니다. 예를 들어, **Fuzzy Query**를 사용하여 **유사한 단어**를 찾는 방식을 적용할 수 있습니다.

---

### 8. **Elastic Search의 응답 형식**
- **별명**
  - 쿼리 응답 형식
  - 검색 결과

- **응답 데이터 형식**
  - Elastic Search는 쿼리에 대한 응답 데이터를 **JSON 형식**으로 반환합니다.
  - 이 **JSON 응답**은 사용자가 원하는 방식으로 **가공**하여 클라이언트에 전달할 수 있습니다. 즉, **서버에서 응답 형식을 설정**할 수 있으며, 필요한 데이터만 필터링하거나 **정렬**할 수도 있습니다.
  - 예를 들어, **`_source` 필드를 사용**하여 원본 데이터를 필터링하거나 **`aggregations`** 기능을 사용하여 집계 데이터를 얻을 수 있습니다.
  - 응답 형식은 **동적으로** 변할 수 있으며, **백엔드 로직에서 추가 가공**을 하여 클라이언트에 전달할 수 있습니다.

---
### 결론

Elasticsearch는 **문서형 데이터**를 다루는 데 적합한 **분산형 검색 엔진**으로, **텍스트 검색** 및 **실시간 데이터 동기화**에 매우 효율적입니다. **RDBMS와의 비교**에서 **고속 검색 성능**과 **분산 처리**의 장점을 제공하며, **Full Text Index**를 지원하고 **fuzzy query**를 통해 일부 오타를 처리할 수 있어 텍스트 기반 검색 시스템에 적합합니다. 또한, **배치 처리**는 **직접 구현**해야 하며, Elasticsearch가 자동으로 배치 작업을 처리하지 않음을 고려해야 합니다.


&nbsp;
&nbsp;

## Elasticsearch vs RDBMS 비교

### 1. **데이터 구조**
   - **Elasticsearch**: 
     - **문서 기반 데이터 저장** (JSON 형식)
     - **비정형 데이터**를 효율적으로 처리
     - **스키마 자유도**가 높으며, 데이터 구조 변경에 유연함
     - 데이터는 **역색인** (Inverted Index) 방식으로 저장되어 텍스트 검색에 최적화
     
   - **RDBMS**:
     - **테이블 기반 데이터 저장** (행(Row)과 열(Column) 구조)
     - **정형 데이터**에 적합하며, **고정된 스키마**를 요구
     - 관계형 데이터 모델을 사용하여 데이터를 **정규화**하고 **외래 키** 등을 통해 관계를 정의
     - **SQL**을 사용하여 데이터 검색, 삽입, 수정 등을 수행

### 2. **검색 성능**
   - **Elasticsearch**:
     - **빠른 텍스트 검색**에 최적화된 **분산형 검색 엔진**
     - **역색인**(Inverted Index)을 사용하여 텍스트 데이터를 빠르게 검색
     - **실시간 검색**에 뛰어나며, 대규모 데이터를 처리할 때 빠른 속도 제공
     - **스케일 아웃**(수평 확장)이 용이하여 **대용량 데이터** 처리 시 성능 유지
     - **근사 검색**(Fuzzy search) 및 **자동완성** 기능 지원

   - **RDBMS**:
     - **정형 데이터**에 대해 높은 **정확도**로 검색 가능
     - **JOIN** 연산 등 복잡한 관계형 쿼리에 적합하지만, 텍스트 기반 검색에는 성능이 떨어짐
     - **인덱싱**을 통해 성능 향상 가능하지만, 기본적으로 **배치 처리**가 필요
     - **수직 확장**(단일 서버의 성능 확장)을 통한 성능 향상이 가능하나, **수평 확장**이 어려운 경우가 많음

### 3. **데이터 일관성**
   - **Elasticsearch**:
     - **Eventual consistency** (최종 일관성 모델)을 사용
     - 분산 시스템이기 때문에 **동기화 지연**이 발생할 수 있음
     - **쓰기 성능**이 우수하지만, **완벽한 일관성**이 요구되는 시스템에는 적합하지 않음
     
   - **RDBMS**:
     - **ACID**(Atomicity, Consistency, Isolation, Durability) 속성을 보장하여 **강한 일관성** 제공
     - 트랜잭션을 통해 데이터의 일관성과 무결성을 보장
     - 다중 사용자 환경에서 **동시성 문제**를 관리하는 데 강력

### 4. **확장성**
   - **Elasticsearch**:
     - **수평 확장**(Horizontal Scaling)을 지원, 즉 클러스터를 통해 여러 노드에 분산
     - **샤딩**(Sharding)과 **리플리케이션**(Replication) 기능을 통해 데이터를 분산 처리
     - **대규모 데이터셋**과 **실시간 검색**에 대해 뛰어난 성능을 제공
     
   - **RDBMS**:
     - 대부분 **수직 확장**(Vertical Scaling)을 사용, 즉 서버 성능을 확장하여 처리
     - **수평 확장**이 어려워 **큰 데이터셋**을 처리할 때 성능 저하가 발생할 수 있음
     - 일부 최신 **분산형 RDBMS**는 수평 확장을 지원하지만, 복잡도가 높음

### 5. **데이터 분석**
   - **Elasticsearch**:
     - **분석** 및 **집계**(Aggregation) 기능에 강점
     - **실시간 데이터 분석**과 **대규모 로그 분석**에 적합
     - 데이터를 빠르게 **집계**하고, 다양한 방식으로 **시각화**할 수 있는 기능 제공
     - **Elasticsearch Kibana**와의 연계를 통해 **로그 분석**, **모니터링**에 유용

   - **RDBMS**:
     - **SQL 쿼리**를 이용한 데이터 분석에 적합
     - 데이터가 정형화되어 있기 때문에 **복잡한 분석** 및 **집계**가 필요할 때 **JOIN**이나 **서브쿼리** 등을 활용해야 함
     - 대용량 데이터를 처리할 때 **성능 저하**가 발생할 수 있으며, **배치 처리**가 필요

### 6. **실시간 데이터 처리**
   - **Elasticsearch**:
     - **실시간 검색**에 최적화되어 있으며, 데이터 변경 시 **즉시 반영** 가능
     - 로그 수집, **실시간 알림** 및 **데이터 스트리밍**에 강력
     - 데이터 **입력 후 검색**이 즉시 가능

   - **RDBMS**:
     - **실시간 처리**에 한계가 있음
     - 데이터가 삽입된 후 **일정 시간이 지난 뒤**에야 검색이 가능
     - 트랜잭션 처리에서 **즉시 일관성**을 보장하지만, 실시간 분석에 적합하지 않음

### 7. **운영 및 관리**
   - **Elasticsearch**:
     - **분산형 시스템**으로 클러스터 및 노드 관리가 필요
     - **유지보수**가 복잡할 수 있으며, **복제** 및 **샤딩**을 잘 설정해야 함
     - 기본적으로 **매니지드 서비스**를 제공하는 서비스(AWS, GCP 등)를 활용하면 관리가 쉬워짐
     
   - **RDBMS**:
     - **정형 데이터 관리**에 최적화되어 있으며, **사용하기 쉽고 직관적**
     - **SQL**을 기반으로 데이터를 쉽게 관리할 수 있음
     - **복잡한 백업 및 복구** 작업은 수동으로 해야 할 수도 있음

### 8. **주요 사용 사례**
   - **Elasticsearch**:
     - **로그 분석** (로그 수집, 실시간 검색)
     - **검색 엔진** (웹사이트, 애플리케이션 검색)
     - **추천 시스템** (사용자 행동 분석)
     - **모니터링 및 알림** (실시간 데이터 모니터링)
     
   - **RDBMS**:
     - **트랜잭션 관리** (은행, 금융 시스템)
     - **정형 데이터 처리** (회계 시스템, 인벤토리 관리)
     - **복잡한 관계형 쿼리** (고객 관리 시스템)
     - **영구 데이터 저장소** (사용자 데이터 저장, 기업 데이터베이스)

### 9. **Elasticsearch vs RDBMS (요약)**

| 항목                          | Elasticsearch                            | RDBMS (관계형 데이터베이스)                   |
|-------------------------------|------------------------------------------|---------------------------------------------|
| **데이터 모델**                | JSON 문서 기반 (No-SQL 스타일)             | 테이블 및 행 기반 (관계형 모델)               |
| **검색 기능**                  | Full-Text Search, Fuzzy Search, Autocomplete 지원 | Full-Text Search (제한적 성능)               |
| **성능**                       | 대규모 데이터에 대해 매우 빠른 검색 성능  | 대규모 데이터에서 성능 저하 가능             |
| **배치 처리**                  | ETL 및 주기적 데이터 반영 필요           | 배치 처리 가능하지만 비효율적일 수 있음      |
| **분산 시스템**                | 샤딩 및 복제 방식으로 분산 처리           | Read Replica로 분산 처리 (주로 읽기 전용)   |
| **실시간 동기화**              | CDC, 트리거 등으로 실시간 동기화 가능    | 실시간 동기화는 일반적으로 복잡함           |
| **오타 교정**                  | Fuzzy Query로 오타에 대한 tolerance 설정 가능 | 기본적으로 오타 교정 지원하지 않음          |
| **응답 형식**                  | JSON 형식으로 응답                       | 기본적으로 SQL 응답 (기본적으로 JSONX)      |

---

### 결론

- **Elasticsearch**는 **비정형 데이터**와 **실시간 검색**을 필요로 하는 시스템에 적합하며, **분산형 시스템**을 통해 **수평 확장**이 가능하고, **대용량 데이터** 처리에 강점이 있습니다. 또한, **빠른 텍스트 검색**과 **로그 분석** 등의 용도에 적합합니다.
  
- **RDBMS**는 **정형 데이터**를 다루고 **ACID 트랜잭션**을 보장하며, **복잡한 관계형 데이터 처리**와 **강한 일관성**이 필요한 경우에 유리합니다. 대규모 데이터를 처리하는 데 한계가 있을 수 있지만, **정밀한 데이터 무결성**과 **SQL**을 통한 강력한 **쿼리 성능**을 제공합니다.

따라서, 사용 사례에 맞춰 **Elasticsearch**와 **RDBMS**를 적절히 선택하거나, 두 시스템을 함께 사용하는 하이브리드 아키텍처를 고려할 수 있습니다.


&nbsp;
&nbsp;

## Additional Info
### 1. **Elasticsearch와 No-SQL의 관계**
   - Elasticsearch는 **문서 기반 검색 엔진**으로, **검색 최적화**가 핵심입니다. **No-SQL 데이터베이스**와 비슷한 특성을 가지지만, **검색**에 특화된 시스템으로, 데이터가 **JSON 형식의 문서**로 저장되고, 데이터 모델이 고정되지 않거나 유연하게 구성할 수 있어 No-SQL의 특성을 일부 공유합니다. 그러나 일반적인 No-SQL 데이터베이스의 기능(예: Key-Value 저장, 확장성 등)과는 약간 다른 목적을 가집니다. Elasticsearch는 **검색 최적화**가 핵심 기능입니다. 이를 통해 데이터를 대규모로 빠르게 검색하는 데 집중하고, 다른 No-SQL 데이터베이스와는 달리 **인덱싱 및 검색 최적화**가 중요한 요소로 작용합니다.

### 2. **RDBMS에서 데이터 변경 시 Elasticsearch에 데이터 넣기 (CDC 및 MQ 제외)**
   - **일반적인 방법**: RDBMS의 DML 작업 (INSERT, UPDATE, DELETE) 발생 시 해당 데이터를 Elasticsearch에 직접 업데이트하는 방식은 **비동기 처리**로 구현하는 것이 일반적입니다.
   - **Kafka와 같은 메시지 큐를 사용하지 않고** RDBMS의 **트리거**나 **애플리케이션 로직**을 통해 데이터 변경을 실시간으로 Elasticsearch에 반영하는 방식도 가능합니다. 예를 들어, **애플리케이션 로직**에서 데이터 변경이 발생할 때마다 해당 데이터를 Elasticsearch에 삽입하거나 업데이트하는 방법이 있습니다.
   - **트리거 사용**: RDBMS에서 트리거를 설정하여 데이터 변경 시 Elasticsearch에 실시간으로 데이터를 전송할 수 있습니다. 하지만 이 방법은 **대규모 트래픽**이 발생할 때 **성능 저하**가 있을 수 있으므로 신중하게 사용해야 합니다.

### 3. **ETL 파이프라인과 실시간 동기화**
   - **ETL 파이프라인**은 주로 **배치 처리** 방식으로 데이터를 추출하고 변환한 뒤 로드하는 과정입니다. 그러나 최근에는 실시간 동기화를 위해 **Change Data Capture (CDC)** 방식이나 **스트리밍 데이터 처리**(예: Kafka)를 사용하여 실시간으로 데이터를 처리할 수 있습니다.
   - **실시간 동기화**는 **배치 방식**과 다르게 실시간으로 데이터 변경을 반영하는 방식입니다. Elasticsearch와 같은 시스템에서는 데이터를 실시간으로 반영하기 위해 **스트리밍 데이터 처리** 방식이 적용될 수 있습니다.

### 4. **배치 작업과 Elasticsearch**
   - **Elasticsearch** 자체는 **배치 작업**을 자동으로 처리하지 않습니다. 따라서 데이터를 주기적으로 Elasticsearch에 반영하려면 **배치 작업을 구현**하는 별도의 **서비스**나 **로직**이 필요합니다.
   - **배치 작업**은 주기적인 작업으로, 예를 들어, 하루에 한 번 또는 일정 주기마다 RDBMS의 데이터를 추출하여 Elasticsearch로 **일괄 전송**하는 방식입니다. 이 과정에서 ETL 툴을 사용하거나, 단순히 스크립트로 주기적으로 데이터를 가져와 반영할 수 있습니다.

### 5. **Full-Text Index와 성능**
   - **Elasticsearch**는 **Full-Text Index**를 기본적으로 지원합니다. RDBMS에서 제공하는 **Full-Text Index** 기능과 비슷한 방식으로, 텍스트 기반의 검색을 최적화하기 위해 **역색인(Inverted Index)**을 사용합니다.
   - **성능** 측면에서는 **Elasticsearch가 훨씬 빠릅니다**. Elasticsearch는 **검색 엔진**으로 최적화되어 있으며, 특히 대규모 텍스트 검색에 매우 효율적입니다. 반면, RDBMS의 Full-Text Index는 검색이 느려질 수 있으며, 대용량 데이터에서는 성능이 저하될 수 있습니다.

### 6. **Elasticsearch의 분산 시스템**
   - **Elasticsearch는 분산 시스템**으로, 데이터는 **샤드(Shard)**로 분할되어 여러 서버에 분산 저장됩니다. RDBMS의 **Read Replica**와는 다릅니다.
   - **Read Replica**는 주로 **마스터-슬레이브** 방식으로 데이터를 복제하여 읽기 성능을 향상시키는 방식입니다. 하지만 **Elasticsearch**는 **샤딩(Sharding)** 방식을 사용하여 데이터를 분산하고, 여러 노드가 데이터를 동시에 처리할 수 있게 설계되어 있습니다.
   - **동기화**: 각 노드는 **마스터 노드**와 통신하여 데이터를 업데이트하고, 데이터 일관성을 보장합니다. 각 샤드는 독립적으로 데이터에 접근하여 쿼리를 처리할 수 있습니다.

### 7. **오타 교정 및 유사 검색**
   - **오타 교정**은 **Elasticsearch**에서 기본적으로 제공되는 기능은 아니지만, **자동완성**이나 **유사 검색**을 설정할 수 있습니다. 예를 들어, **fuzzy query**를 사용하면 **오타**에 대해서도 검색 결과를 반환할 수 있습니다.
   - **자동완성**: Elasticsearch는 **autocomplete** 기능을 제공하여, 사용자가 검색할 때 입력하는 단어를 미리 예측하여 추천할 수 있습니다.
   - **Tolerance 설정**: Elasticsearch에서 **fuzzy query**나 **edge n-gram**을 사용하면 오타가 있을 때도 유사한 단어를 검색할 수 있도록 설정할 수 있습니다.

### 8. **Elasticsearch 쿼리 응답 형식**
   - Elasticsearch의 쿼리 응답 형식은 **JSON**입니다. Elasticsearch는 검색 결과를 **JSON** 형식으로 반환합니다.
   - 응답 데이터를 **백엔드에서 가공**하여 클라이언트에 전달할 수 있으며, **응답 형식**을 **커스터마이즈**할 수 있습니다. 예를 들어, 검색 결과를 **필터링**하거나 **정렬**한 뒤 클라이언트가 필요한 정보만을 추출하여 전송할 수 있습니다.